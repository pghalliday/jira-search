// Generated by CoffeeScript 1.9.3
(function() {
  var Q, request;

  request = require('superagent');

  Q = require('q');

  module.exports = function(params) {
    var searchRequest;
    params.onTotal = params.onTotal || function() {};
    params.mapCallback = params.mapCallback || function(issue) {
      return issue;
    };
    searchRequest = function(startAt, maxResults, fields, expand) {
      var query;
      query = request.get(params.serverRoot + '/rest/api/2/search').query({
        jql: params.jql,
        maxResults: maxResults,
        startAt: startAt,
        fields: fields,
        expand: expand
      });
      if (params.user) {
        query.auth(params.user, params.pass);
      }
      return query;
    };
    return Q().then(function() {
      var deferred, query;
      query = searchRequest(0, 0, '', '');
      deferred = Q.defer();
      query.end(function(error, response) {
        if (error) {
          return deferred.reject(error);
        } else {
          return deferred.resolve(response.body.total);
        }
      });
      return deferred.promise;
    }).then(function(total) {
      var issuesPromise, issuesPromiseCalls, remaining, start;
      params.onTotal(total);
      remaining = total;
      issuesPromise = function(start, array) {
        var deferred, query;
        deferred = Q.defer();
        query = searchRequest(start, params.maxResults, params.fields, params.expand);
        query.end(function(error, response) {
          var issue, issues;
          if (error) {
            return deferred.reject(error);
          } else {
            issues = (function() {
              var i, len, ref, results;
              ref = response.body.issues;
              results = [];
              for (i = 0, len = ref.length; i < len; i++) {
                issue = ref[i];
                results.push(params.mapCallback(issue));
              }
              return results;
            })();
            return deferred.resolve(array.concat(issues));
          }
        });
        return deferred.promise;
      };
      issuesPromiseCalls = (function() {
        var results;
        results = [];
        while (remaining > 0) {
          start = total - remaining;
          remaining -= params.maxResults;
          results.push(issuesPromise.bind(null, start));
        }
        return results;
      })();
      return issuesPromiseCalls.reduce(function(soFar, f) {
        return soFar.then(f);
      }, Q([]));
    });
  };

}).call(this);
